% Face class contains properties and methods related to the 
% variables stored in cell face.
classdef Face < handle
    properties(SetAccess = private)
        u
        uOld
        uTemp
        v
        vOld
        vTemp
    end
    
    properties
        forceX
        forceY        
    end
    
    methods
        %%
        function obj = Face(domain)
        % Initialize variables stored at cell Face (liquid is at rest at
        % the beginning).    
            % Velocities in x-direction.
            [obj.u, obj.uOld, obj.uTemp] = deal(zeros(domain.nx+1, ...
                domain.ny+2));
            % Velocities in y-direction.
            [obj.v, obj.vOld, obj.vTemp] = deal(zeros(domain.nx+2, ...
                domain.ny+1));
            % Forces in x and y directions.
            [obj.forceX, obj.forceY] = deal(zeros(domain.nx+2, ...
                domain.ny+2));
        end
        
        %% 
        function storeOldVariables(obj)
        % Store old variables for second order scheme.    
            obj.uOld = obj.u;
            obj.vOld = obj.v;
        end
        
        %%
        function store2ndOrderVariables(obj)
        % Store second order variables.    
           obj.u = 0.5*(obj.u+obj.uOld);
           obj.v = 0.5*(obj.v+obj.vOld);
        end
        
        %% 
        function initializeForce(obj, domain)
        % Set the forces to zero.    
           [obj.forceX, obj.forceY] = deal(zeros(domain.nx+2, domain.ny+2)); 
        end
        
        %% 
        function updateWallVelocity(obj, domain)
        % Update the tangential velocity at boundaries. The domain is 
        % assumed as a box with no-slip boundary condition.
            uSouth = 0;
            uNorth = 0;
            vWest = 0;
            vEast = 0;
            obj.u(1:domain.nx+1,1) = 2*uSouth-obj.u(1:domain.nx+1,2);
            obj.u(1:domain.nx+1,domain.ny+2) = ...
                2*uNorth-obj.u(1:domain.nx+1,domain.ny+1);
            obj.v(1,1:domain.ny+1) = 2*vWest -obj.v(2,1:domain.ny+1);
            obj.v(domain.nx+2,1:domain.ny+1) = ...
                2*vEast -obj.v(domain.nx+1,1:domain.ny+1);
        end
        
        %%
        function calculateTemporaryVelocity(obj, param, domain, ...
                fluidProp, fluid)
        % Calculate the temporary velocities without accounting for 
        % the pressure (first step of the second order projection method).    
            % Temporary u velocity (advection term).
            for i=2:domain.nx
                for j=2:domain.ny+1
                    obj.uTemp(i,j) = obj.u(i,j)+param.dt*(-0.25* ...
                        (((obj.u(i+1,j  )+obj.u(i  ,j  ))^2- ...
                          (obj.u(i  ,j  )+obj.u(i-1,j  ))^2)/domain.dx+ ...
                         ((obj.u(i  ,j+1)+obj.u(i  ,j  ))* ...
                          (obj.v(i+1,j  )+obj.v(i  ,j  ))- ...
                          (obj.u(i  ,j  )+obj.u(i  ,j-1))* ...
                          (obj.v(i+1,j-1)+obj.v(i  ,j-1)))/domain.dy)+ ...
                           obj.forceX(i,j)/ ...
                          (0.5*(fluid.rho(i+1,j)+fluid.rho(i,j)))- ...
                          (1.0 -fluidProp.contRho/ ...
                          (0.5*(fluid.rho(i+1,j)+fluid.rho(i,j))))* ...
                          domain.gravx);
                end
            end

            % Temporary v velocity (advection term).
            for i=2:domain.nx+1
                for j=2:domain.ny
                    obj.vTemp(i,j) = obj.v(i,j)+param.dt*(-0.25* ...
                        (((obj.u(i  ,j+1)+obj.u(i  ,j  ))* ...
                          (obj.v(i+1,j  )+obj.v(i  ,j  ))- ...
                          (obj.u(i-1,j+1)+obj.u(i-1,j  ))* ...
                          (obj.v(i  ,j  )+obj.v(i-1,j  )))/domain.dx+ ...
                         ((obj.v(i  ,j+1)+obj.v(i  ,j  ))^2- ...
                          (obj.v(i  ,j  )+obj.v(i  ,j-1))^2)/domain.dy)+ ...
                           obj.forceY(i,j)/ ...
                          (0.5*(fluid.rho(i,j+1)+fluid.rho(i,j)))- ...
                          (1.0 -fluidProp.contRho/ ...
                          (0.5*(fluid.rho(i,j+1)+fluid.rho(i,j))))* ...
                          domain.gravy);
                end
            end

            % Temporary u velocity (diffusion term).
            for i=2:domain.nx
                for j=2:domain.ny+1
                    obj.uTemp(i,j) = obj.uTemp(i,j)+param.dt* ...
                        ((1./domain.dx)*2.* ...
                    (fluid.mu(i+1,j  )*(1./domain.dx)* ...
                    (obj.u(i+1,j  )-obj.u(i  ,j  )) - ... 
                     fluid.mu(i  ,j  )*(1./domain.dx)* ...
                    (obj.u(i  ,j  )-obj.u(i-1,j  )))+ ...
                    (1./domain.dy)*(0.25* ...
                    (fluid.mu(i  ,j  )+fluid.mu(i+1,j  )+ ...          
                     fluid.mu(i+1,j+1)+fluid.mu(i  ,j+1))* ...                              
                    ((1./domain.dy)*(obj.u(i  ,j+1)-obj.u(i  ,j  ))+ ... 
                     (1./domain.dx)*(obj.v(i+1,j  )-obj.v(i  ,j  )))-0.25* ...
                    (fluid.mu(i  ,j  )+fluid.mu(i+1,j  )+ ...
                     fluid.mu(i+1,j-1)+fluid.mu(i  ,j-1))* ...
                    ((1./domain.dy)*(obj.u(i  ,j  )-obj.u(i  ,j-1))+ ...
                     (1./domain.dx)*(obj.v(i+1,j-1)-obj.v(i  ,j-1)))))/ ...
                     (0.5*(fluid.rho(i+1,j)+fluid.rho(i,j)));
                end
            end

            % Temporary v velocity (diffusion term).
            for i=2:domain.nx+1
                for j=2:domain.ny
                    obj.vTemp(i,j) = obj.vTemp(i,j)+param.dt* ...
                        ((1./domain.dx)*(0.25* ...
                    (fluid.mu(i  ,j  )+fluid.mu(i+1,j  )+ ...
                     fluid.mu(i+1,j+1)+fluid.mu(i,j+1  ))* ...
                    ((1./domain.dy)*(obj.u(i  ,j+1)-obj.u(i  ,j  ))+ ...                    
                     (1./domain.dx)*(obj.v(i+1,j  )-obj.v(i  ,j  )))-0.25* ...              
                    (fluid.mu(i  ,j  )+fluid.mu(i  ,j+1)+ ...                                
                     fluid.mu(i-1,j+1)+fluid.mu(i-1,j  ))* ...                                
                    ((1./domain.dy)*(obj.u(i-1,j+1)-obj.u(i-1,j  ))+ ...
                     (1./domain.dx)*(obj.v(i  ,j  )-obj.v(i-1,j  ))))+ ...
                     (1./domain.dy)*2.* ...
                    (fluid.mu(i  ,j+1)*(1./domain.dy)* ...
                    (obj.v(i  ,j+1)-obj.v(i  ,j  ))- ...  
                     fluid.mu(i  ,j  )*(1./domain.dy)* ...
                    (obj.v(i  ,j  )-obj.v(i  ,j-1))))/ ...
                     (0.5*(fluid.rho(i,j+1)+fluid.rho(i,j)));                                   
                end
            end
        end
        
        %%
        function correctVelocity(obj, domain, param, center, fluid)
        % Correct the velocity by adding the pressure gradient.    
            % Velocity in x-direction.
            for i=2:domain.nx
                for j=2:domain.ny+1
                    obj.u(i,j) = obj.uTemp(i,j)-param.dt*(2.0/domain.dx)* ...
                        (center.pres(i+1,j)-center.pres(i,j))/ ...
                        (fluid.rho(i+1,j)+fluid.rho(i,j));
                end
            end
            % Velocity in y-direction.
            for i=2:domain.nx+1
                for j=2:domain.ny
                    obj.v(i,j) = obj.vTemp(i,j)-param.dt*(2.0/domain.dy)* ...
                        (center.pres(i,j+1)-center.pres(i,j))/ ...
                        (fluid.rho(i,j+1)+fluid.rho(i,j));
                end
            end
        end

    end
end
